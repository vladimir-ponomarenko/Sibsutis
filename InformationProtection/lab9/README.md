# Лабораторная работа №9: Электронная подпись Эль-Гамаля

## Описание
Реализация алгоритма электронной подписи Эль-Гамаля для подписания и проверки файлов. Алгоритм основан на проблеме дискретного логарифма и обеспечивает аутентификацию и целостность данных.

## Теоретические основы

### Алгоритм подписи Эль-Гамаля
Схема подписи Эль-Гамаля - это цифровая подпись, основанная на проблеме дискретного логарифма в конечных полях. Алгоритм обеспечивает аутентификацию и целостность данных.

### Математические основы
- **Проблема дискретного логарифма**: Для данных g, p, y найти x такое, что g^x ≡ y (mod p)
- **Первообразный корень**: Элемент g по модулю p, если порядок g равен φ(p) = p-1
- **Модульная арифметика**: Все вычисления выполняются по модулю p

### Генерация ключей
1. **Выбор параметров**:
   - Выбирается большое простое число p (минимум 1024 бита для безопасности)
   - Выбирается первообразный корень g по модулю p
   
2. **Генерация ключей**:
   - Выбирается случайное число x ∈ [1, p-1] (закрытый ключ)
   - Вычисляется y = g^x mod p (открытый ключ)
   - Публикуется (p, g, y) - открытый ключ
   - Сохраняется x - закрытый ключ

### Процесс подписания
Для хеша H сообщения (полученного через SHA-256):

1. **Выбор случайного числа**:
   - Выбирается случайное число k ∈ [1, p-1] такое, что НОД(k, p-1) = 1
   - Это обеспечивает существование обратного элемента k^(-1)

2. **Вычисление r**:
   - r = g^k mod p
   - r является частью подписи

3. **Вычисление s**:
   - s = k^(-1) * (H - x*r) mod (p-1)
   - s является второй частью подписи

4. **Результат**: Подпись (r, s)

### Процесс проверки
Для подписи (r, s) и хеша H:

1. **Проверка диапазонов**:
   - Проверяется: 1 ≤ r < p и 1 ≤ s < p-1
   - Если условие не выполнено, подпись неверна

2. **Проверка подписи**:
   - Вычисляется левая часть: g^H mod p
   - Вычисляется правая часть: (y^r * r^s) mod p
   - Проверяется: g^H ≡ y^r * r^s (mod p)

3. **Результат**: True, если подпись верна, иначе False

### Алгоритм в коде
```python
def elgamal_sign(hash_digest: bytes, p: int, g: int, x: int) -> Tuple[int, int]:
    # 1. Преобразование хеша в число
    h = int.from_bytes(hash_digest, byteorder='big') % (p - 1)
    
    # 2. Выбор случайного k
    while True:
        k = random.randrange(1, p - 1)
        if extended_gcd(k, p - 1)[0] == 1:
            break
    
    # 3. Вычисление r
    r = mod_pow(g, k, p)
    
    # 4. Вычисление s
    k_inv = mod_inverse(k, p - 1)
    s = (k_inv * (h - x * r)) % (p - 1)
    
    return r, s

def elgamal_verify(hash_digest: bytes, signature: Tuple[int, int], p: int, g: int, y: int) -> bool:
    r, s = signature
    
    # 1. Проверка диапазонов
    if r < 1 or r >= p or s < 1 or s >= p - 1:
        return False
    
    # 2. Преобразование хеша
    h = int.from_bytes(hash_digest, byteorder='big') % (p - 1)
    
    # 3. Проверка подписи
    left = mod_pow(g, h, p)
    right = (mod_pow(y, r, p) * mod_pow(r, s, p)) % p
    
    return left == right
```

## Использование

### Генерация ключей
```bash
python main.py generate --bits 64 --pub public.key --priv private.key
```

### Подписание файла
```bash
python main.py sign file.txt --key private.key --out file.sig
```

### Проверка подписи
```bash
python main.py verify file.txt --key public.key --sig file.sig
```

### Параметры командной строки
- `generate` - генерация пары ключей
- `sign` - подписание файла
- `verify` - проверка подписи
- `--bits` - размер простого числа в битах (по умолчанию 32)
- `--pub` - файл для открытого ключа
- `--priv` - файл для закрытого ключа
- `--key` - файл с ключом для подписания/проверки
- `--out` - файл для сохранения подписи
- `--sig` - файл с подписью для проверки

## Особенности реализации
- Использование SHA-256 для хеширования файлов
- Автоматический поиск первообразного корня
- Проверка корректности параметров подписи
- Сохранение/загрузка ключей и подписей в файлы
- Обработка больших чисел (Python int неограничен)

## Безопасность
- Основан на сложности вычисления дискретного логарифма
- Требует больших простых чисел для обеспечения безопасности
- Использует случайное число k для каждой подписи
- Устойчив к атакам на основе известных подписей

## Преимущества
- Быстрая генерация ключей
- Эффективная проверка подписи
- Возможность предварительного вычисления r
- Широкое применение в криптографии

## Ограничения
- Требует генерации случайного k для каждой подписи
- Размер подписи зависит от размера модуля p
- Необходимость хранения закрытого ключа в секрете
- Производительность зависит от размера модуля p

## Математические основы
- Проблема дискретного логарифма: найти x такое, что g^x ≡ y (mod p)
- Теорема Эйлера: a^φ(n) ≡ 1 (mod n) для НОД(a, n) = 1
- Расширенный алгоритм Евклида для нахождения обратного элемента
- Китайская теорема об остатках для ускорения вычислений
