# Лабораторная работа №9: Электронная подпись Эль-Гамаля

## Описание
Реализация алгоритма электронной подписи Эль-Гамаля для подписания и проверки файлов. Алгоритм основан на проблеме дискретного логарифма и обеспечивает аутентификацию и целостность данных.

## Теоретические основы

### Алгоритм подписи Эль-Гамаля
Схема подписи Эль-Гамаля - это цифровая подпись, основанная на проблеме дискретного логарифма в конечных полях. Алгоритм обеспечивает аутентификацию и целостность данных.

### Математические основы
- **Проблема дискретного логарифма**: Для данных g, p, y найти x такое, что g^x ≡ y (mod p)
- **Первообразный корень**: Элемент g по модулю p, если порядок g равен φ(p) = p-1
- **Модульная арифметика**: Все вычисления выполняются по модулю p

### Генерация ключей
1. **Выбор параметров**:
   - Выбирается большое простое число p (минимум 1024 бита для безопасности)
   - Выбирается первообразный корень g по модулю p
   
2. **Генерация ключей**:
   - Выбирается случайное число x ∈ [1, p-1] (закрытый ключ)
   - Вычисляется y = g^x mod p (открытый ключ)
   - Публикуется (p, g, y) - открытый ключ
   - Сохраняется x - закрытый ключ

### Процесс подписания (побайтовый)
Согласно требованиям задания, хеш-функция SHA-256 обрабатывается побайтово:

1. **Разбиение хеша на байты**:
   - Хеш H разбивается на 32 байта: H = [h₁, h₂, ..., h₃₂]
   - Каждый байт hᵢ подписывается отдельно

2. **Для каждого байта hᵢ**:
   - Выбирается случайное число kᵢ ∈ [1, p-1] такое, что НОД(kᵢ, p-1) = 1
   - Вычисляется rᵢ = g^(kᵢ) mod p
   - Вычисляется sᵢ = kᵢ^(-1) * (hᵢ - x*rᵢ) mod (p-1)

3. **Результат**: Подпись [(r₁, s₁), (r₂, s₂), ..., (r₃₂, s₃₂)]

### Процесс проверки (побайтовый)
Для подписи [(r₁, s₁), (r₂, s₂), ..., (r₃₂, s₃₂)] и хеша H = [h₁, h₂, ..., h₃₂]:

1. **Проверка длины**:
   - Проверяется: длина подписи = 32 пары (r, s)
   - Если условие не выполнено, подпись неверна

2. **Для каждой пары (rᵢ, sᵢ) и байта hᵢ**:
   - Проверяется: 1 ≤ rᵢ < p и 1 ≤ sᵢ < p-1
   - Вычисляется левая часть: g^(hᵢ) mod p
   - Вычисляется правая часть: (y^(rᵢ) * rᵢ^(sᵢ)) mod p
   - Проверяется: g^(hᵢ) ≡ y^(rᵢ) * rᵢ^(sᵢ) (mod p)

3. **Результат**: True, если все 32 проверки прошли успешно, иначе False

### Алгоритм в коде (побайтовый)
```python
def elgamal_sign(hash_digest: bytes, p: int, g: int, x: int) -> list[Tuple[int, int]]:
    signature = []
    
    for byte in hash_digest:
        # 1. Выбор случайного k для каждого байта
        while True:
            k = random.randrange(1, p - 1)
            if extended_gcd(k, p - 1)[0] == 1:
                break
        
        # 2. Вычисление r
        r = mod_pow(g, k, p)
        
        # 3. Вычисление s
        k_inv = mod_inverse(k, p - 1)
        h = byte % (p - 1)
        s = (k_inv * (h - x * r)) % (p - 1)
        
        signature.append((r, s))
    
    return signature

def elgamal_verify(hash_digest: bytes, signature: list[Tuple[int, int]], p: int, g: int, y: int) -> bool:
    if len(signature) != len(hash_digest):
        return False
    
    for i, (r, s) in enumerate(signature):
        # 1. Проверка диапазонов
        if r < 1 or r >= p or s < 1 or s >= p - 1:
            return False
        
        # 2. Получение байта хеша
        h = hash_digest[i] % (p - 1)
        
        # 3. Проверка подписи
        left = mod_pow(g, h, p)
        right = (mod_pow(y, r, p) * mod_pow(r, s, p)) % p
        
        if left != right:
            return False
    
    return True
```

## Использование

### Генерация ключей
```bash
python main.py generate --bits 64 --pub public.key --priv private.key
```

### Подписание файла
```bash
python main.py sign file.txt --key private.key --out file.sig
```

### Проверка подписи
```bash
python main.py verify file.txt --key public.key --sig file.sig
```

### Параметры командной строки
- `generate` - генерация пары ключей
- `sign` - подписание файла
- `verify` - проверка подписи
- `--bits` - размер простого числа в битах (по умолчанию 128)
- `--pub` - файл для открытого ключа
- `--priv` - файл для закрытого ключа
- `--key` - файл с ключом для подписания/проверки
- `--out` - файл для сохранения подписи
- `--sig` - файл с подписью для проверки

## Особенности реализации
- Использование SHA-256 для хеширования файлов
- Автоматический поиск первообразного корня
- Проверка корректности параметров подписи
- Сохранение/загрузка ключей и подписей в файлы
- Обработка больших чисел (Python int неограничен)

## Безопасность
- Основан на сложности вычисления дискретного логарифма
- Требует больших простых чисел для обеспечения безопасности
- Использует случайное число k для каждой подписи
- Устойчив к атакам на основе известных подписей

## Преимущества
- Быстрая генерация ключей
- Эффективная проверка подписи
- Возможность предварительного вычисления r
- Широкое применение в криптографии

## Ограничения
- Требует генерации случайного k для каждой подписи
- Размер подписи зависит от размера модуля p
- Необходимость хранения закрытого ключа в секрете
- Производительность зависит от размера модуля p

## Математические основы
- Проблема дискретного логарифма: найти x такое, что g^x ≡ y (mod p)
- Теорема Эйлера: a^φ(n) ≡ 1 (mod n) для НОД(a, n) = 1
- Расширенный алгоритм Евклида для нахождения обратного элемента
- Китайская теорема об остатках для ускорения вычислений
