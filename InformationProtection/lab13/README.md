# Лабораторная работа №13: Слепая подпись для анонимного голосования

## Описание
Реализация системы анонимного голосования с использованием протокола слепой подписи. Система обеспечивает анонимность голосующих, целостность бюллетеней и возможность проверки результатов голосования.

## Теоретические основы

### Слепая подпись
Слепая подпись - это криптографический протокол, который позволяет подписывать сообщения без знания их содержимого. Это обеспечивает анонимность и конфиденциальность.

### Протокол слепой подписи (на базе RSA)
1. **Ослепление**: Избиратель ослепляет свой выбор случайным фактором r
2. **Подписание**: Сервер подписывает ослепленное сообщение своим закрытым ключом
3. **Снятие ослепления**: Избиратель снимает ослепление с подписи
4. **Проверка**: Любой может проверить подпись, но не узнать, кто голосовал

### Математические основы (RSA)
- **Модуль**: n = p * q, где p и q - простые числа
- **Открытый ключ**: (n, e), где e * d ≡ 1 (mod φ(n))
- **Закрытый ключ**: (n, d)
- **Ослепление**: h' = h * r^e mod n
- **Подпись**: s' = (h')^d mod n
- **Разослепление**: s = s' * r^(-1) mod n
- **Проверка**: s^e mod n = h

## Алгоритм работы

### 1. Инициализация системы
**Криптографические параметры RSA**:
- Генерируются простые числа p и q
- Вычисляется модуль n = p * q
- Выбирается открытый ключ e (обычно 65537)
- Вычисляется закрытый ключ d: e * d ≡ 1 (mod φ(n))

**Генерация ключей**:
```python
def generate_rsa_keys(self, bits: int) -> Tuple[int, int, int]:
    if bits <= 32:
        p = 61  # Простое число
        q = 53  # Простое число
    else:
        p = 1009  # Простое число
        q = 1013  # Простое число
        
    n = p * q
    phi_n = (p - 1) * (q - 1)
    
    # Выбираем e (открытый ключ)
    e = 65537
    while self.gcd(e, phi_n) != 1:
        e += 2
        
    # Вычисляем d (закрытый ключ)
    d = self.mod_inverse(e, phi_n)
    
    return n, e, d
```

### 2. Процесс голосования
**Выбор избирателя**:
- Избиратель выбирает вариант голосования (например, "Да", "Нет", "Воздержался")
- Выбор представляется строкой

**Генерация хеша**:
- Выбор хешируется с помощью SHA-256: h = H(choice)
- Хеш преобразуется в число: h = int.from_bytes(hash_bytes, byteorder='big') % n

**Ослепление сообщения**:
```python
def blind_message(self, message: str) -> Tuple[int, int]:
    h = self.hash_message(message)
    
    # Выбираем случайное r такое, что gcd(r, n) = 1
    while True:
        r = random.randint(1, self.n - 1)
        if self.gcd(r, self.n) == 1:
            break
    
    # h' = h * r^e mod n
    blinded_message = (h * self.mod_pow(r, self.e, self.n)) % self.n
    
    return blinded_message, r
```

### 3. Подписание сервером
**Получение ослепленного сообщения**:
- Сервер получает m' от избирателя
- Сервер не знает исходное сообщение m

**Подписание**:
- Сервер подписывает ослепленное сообщение: s' = (m')^x mod p
- Подпись s' возвращается избирателю

### 4. Снятие ослепления
**Вычисление обратного элемента**:
- Избиратель вычисляет r^(-1) mod p
- Используется расширенный алгоритм Евклида

**Снятие ослепления**:
- s = s' * r^(-1) mod p
- Получается подпись для исходного сообщения m

### 5. Проверка подписи
**Публичная проверка**:
- Любой может проверить подпись: g^m ≡ y^s (mod p)
- m - исходное сообщение (хеш выбора)
- s - подпись после снятия ослепления

**Верификация**:
- Если равенство выполняется, подпись верна
- Подпись подтверждает подлинность выбора
- Невозможно определить, кто голосовал

### Алгоритм в коде
```python
def blind_message(self, message: int, r: int) -> int:
    """Ослепляет сообщение для подписи"""
    return (message * pow(self.y, r, self.p)) % self.p

def sign_blinded_message(self, blinded_message: int) -> int:
    """Подписывает ослепленное сообщение"""
    return pow(blinded_message, self.x, self.p)

def unblind_signature(self, signature: int, r: int) -> int:
    """Снимает ослепление с подписи"""
    r_inv = pow(r, -1, self.p - 1)
    return (signature * pow(r_inv, 1, self.p)) % self.p

def verify_signature(self, message: int, signature: int) -> bool:
    """Проверяет подпись сообщения"""
    return pow(self.g, message, self.p) == pow(self.y, signature, self.p)
```

### Протокол слепой подписи
**Шаг 1 - Подготовка**:
1. Избиратель: choice → H = SHA256(choice) → m = H mod p
2. Избиратель: выбирает r ∈ [1, p-1]
3. Избиратель: m' = m * y^r mod p

**Шаг 2 - Подписание**:
4. Избиратель → Сервер: m'
5. Сервер: s' = (m')^x mod p
6. Сервер → Избиратель: s'

**Шаг 3 - Снятие ослепления**:
7. Избиратель: r^(-1) mod p
8. Избиратель: s = s' * r^(-1) mod p

**Шаг 4 - Проверка**:
9. Любой: проверяет g^m ≡ y^s (mod p)

### Свойства протокола
**Анонимность**:
- Сервер не знает, кто голосовал
- Невозможно связать подпись с избирателем
- Сохраняется конфиденциальность выбора

**Целостность**:
- Подпись подтверждает подлинность выбора
- Невозможно подделать голос
- Проверка подписи гарантирует корректность

**Проверяемость**:
- Любой может проверить подпись
- Результаты голосования прозрачны
- Возможность аудита системы

## Использование

### Запуск сервера

**Интерактивный режим**:
```bash
python main.py --mode server --bits 64
```

**Режим демона (фоновый)**:
```bash
python main.py --mode server --bits 64 --daemon
```

### Голосование (клиент)
```bash
python main.py --mode client --voter-id "voter1" --choice "Да" --bits 64
```

### Команды сервера
- `process` - обработать все бюллетени
- `results` - показать результаты голосования
- `status` - показать статус системы
- `quit` - выйти из программы

### Параметры командной строки
- `--mode` - режим работы (server/client)
- `--voter-id` - ID избирателя (только для клиента)
- `--choice` - выбор избирателя (только для клиента)
- `--bits` - размер параметров в битах (по умолчанию 32)
- `--daemon` - запуск сервера в режиме демона (без интерактивного ввода)

### Режимы работы сервера
1. **Интерактивный режим**: Полный доступ к командам через консоль
2. **Режим демона**: Сервер работает в фоне без интерактивного ввода

## Особенности реализации

### Архитектура системы
- **Сервер**: Обрабатывает бюллетени и ведет учет
- **Клиент**: Подает голос и получает подпись
- **Протокол**: Обеспечивает анонимность и целостность

### Криптографические функции
- Генерация параметров системы
- Ослепление и снятие ослепления
- Подписание и проверка подписей
- Хеширование выборов

### Безопасность
- Анонимность голосующих
- Целостность бюллетеней
- Защита от повторного голосования
- Проверяемость результатов

## Преимущества системы

### Анонимность
- Сервер не знает, кто за что голосовал
- Невозможно связать бюллетень с избирателем
- Сохраняется конфиденциальность выбора

### Целостность
- Все бюллетени подписаны сервером
- Невозможно подделать голос
- Проверка подлинности каждого бюллетеня

### Проверяемость
- Любой может проверить подпись
- Результаты голосования прозрачны
- Возможность аудита системы

## Ограничения и улучшения

### Текущие ограничения
- Отсутствие защиты от атак
- Нет защиты от сговора

### Возможные улучшения
- Добавление защиты от атак
- Реализация полного протокола
- Добавление верификации
- Улучшение безопасности

## Математические основы

### Модульная арифметика
- Операции по модулю простого числа p
- Обратные элементы для снятия ослепления
- Случайные числа для факторов ослепления

### Криптографические примитивы
- Генерация простых чисел
- Поиск первообразных корней
- Хеширование сообщений
- Подписание и проверка

## Применение

### Электронное голосование
- Онлайн-выборы
- Референдумы
- Опросы общественного мнения
- Корпоративные голосования

### Другие применения
- Анонимные платежи
- Защита конфиденциальности
- Криптографические протоколы
- Системы аутентификации
