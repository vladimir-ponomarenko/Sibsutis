# Лабораторная работа №10: Электронная подпись ГОСТ Р 34.10-94

## Описание
Реализация алгоритма электронной подписи ГОСТ Р 34.10-94 для подписания и проверки файлов. Это российский стандарт цифровой подписи, основанный на проблеме дискретного логарифма.

## Теоретические основы

### Алгоритм подписи ГОСТ Р 34.10-94
Схема подписи ГОСТ Р 34.10-94 - это российский стандарт цифровой подписи, основанный на проблеме дискретного логарифма в подгруппе простого порядка.

### Генерация ключей
1. Выбирается простое число q
2. Выбирается простое число p = k*q + 1 для некоторого k
3. Выбирается элемент a порядка q по модулю p
4. Выбирается случайное число x ∈ [1, q-1] (закрытый ключ)
5. Вычисляется y = a^x mod p (открытый ключ)

### Процесс подписания (побайтовый)
Согласно требованиям задания, хеш-функция SHA-256 обрабатывается побайтово:

1. **Разбиение хеша на байты**:
   - Хеш H разбивается на 32 байта: H = [h₁, h₂, ..., h₃₂]
   - Каждый байт hᵢ подписывается отдельно

2. **Для каждого байта hᵢ**:
   - Выбирается случайное число kᵢ ∈ [1, q-1]
   - Вычисляется rᵢ = (a^(kᵢ) mod p) mod q
   - Вычисляется sᵢ = (kᵢ * hᵢ + x * rᵢ) mod q (формула ГОСТ)

3. **Результат**: Подпись [(r₁, s₁), (r₂, s₂), ..., (r₃₂, s₃₂)]

### Процесс проверки (побайтовый)
Для подписи [(r₁, s₁), (r₂, s₂), ..., (r₃₂, s₃₂)] и хеша H = [h₁, h₂, ..., h₃₂]:

1. **Проверка длины**:
   - Проверяется: длина подписи = 32 пары (r, s)
   - Если условие не выполнено, подпись неверна

2. **Для каждой пары (rᵢ, sᵢ) и байта hᵢ**:
   - Проверяется: 1 ≤ rᵢ < q и 1 ≤ sᵢ < q
   - Вычисляется hᵢ^(-1) mod q
   - Вычисляется u1 = (sᵢ * hᵢ^(-1)) mod q
   - Вычисляется u2 = (-rᵢ * hᵢ^(-1)) mod q
   - Вычисляется v = (a^u1 * y^u2 mod p) mod q
   - Проверяется: v = rᵢ

3. **Результат**: True, если все 32 проверки прошли успешно, иначе False

## Использование

### Генерация ключей
```bash
python main.py generate --bits 64 --pub public.key --priv private.key
```

### Подписание файла
```bash
python main.py sign file.txt --key private.key --out file.sig
```

### Проверка подписи
```bash
python main.py verify file.txt --key public.key --sig file.sig
```

### Параметры командной строки
- `generate` - генерация пары ключей
- `sign` - подписание файла
- `verify` - проверка подписи
- `--bits` - размер простого числа q в битах (p будет 1024 бита, по умолчанию 256)
- `--pub` - файл для открытого ключа
- `--priv` - файл для закрытого ключа
- `--key` - файл с ключом для подписания/проверки
- `--out` - файл для сохранения подписи
- `--sig` - файл с подписью для проверки

## Особенности реализации
- Использование SHA-256 для хеширования файлов
- Генерация параметров p и q с требуемыми свойствами
- Поиск элемента порядка q по модулю p
- Проверка корректности параметров подписи
- Сохранение/загрузка ключей и подписей в файлы

## Безопасность
- Основан на сложности вычисления дискретного логарифма в подгруппе
- Требует больших простых чисел для обеспечения безопасности
- Использует случайное число k для каждой подписи
- Устойчив к атакам на основе известных подписей

## Преимущества
- Российский стандарт, одобренный для использования
- Быстрая генерация ключей
- Эффективная проверка подписи
- Возможность предварительного вычисления r
- Широкое применение в российских системах

## Ограничения
- Требует генерации случайного k для каждой подписи
- Размер подписи зависит от размера q
- Необходимость хранения закрытого ключа в секрете
- Производительность зависит от размера параметров

## Математические основы
- Проблема дискретного логарифма в подгруппе: найти x такое, что a^x ≡ y (mod p)
- Теорема Эйлера: a^φ(n) ≡ 1 (mod n) для НОД(a, n) = 1
- Расширенный алгоритм Евклида для нахождения обратного элемента
- Китайская теорема об остатках для ускорения вычислений

## Отличия от других схем
- Использует подгруппу простого порядка q
- Более сложная процедура проверки подписи
- Требует специальных параметров p и q
- Оптимизирован для российских криптографических стандартов
